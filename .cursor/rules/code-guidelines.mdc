---
alwaysApply: true
---

# Code Guidelines for aero-pi-cam

Quick reference for AI-assisted development. The codebase itself is the primary reference.

## Python Version

- **Target**: Python 3.13.5 (Raspberry Pi default)
- **Range**: >=3.11, <3.14
- Use modern type syntax: `X | None` over `Optional[X]`, `datetime.UTC` over `timezone.utc`

## Type Annotations (Required)

- All functions must have parameter and return type annotations
- Use `mypy` strict mode (`disallow_untyped_defs = true`)
- Prefer `collections.abc.Callable` over `typing.Callable`
- Use `dict[str, Any]` not `Dict[str, Any]`

## UTC Time Handling (Critical)

**All times MUST be UTC for aeronautical compliance:**

- ✅ `datetime.now(UTC)` or `datetime.now(timezone.utc)`
- ✅ ISO 8601 with 'Z' suffix: `2026-01-02T15:30:00Z`
- ✅ Log format: `"2026-01-02 15:30:00 UTC"`
- ❌ Never use `datetime.now()` without timezone
- ❌ Never use local timezone or DST conversions
- ❌ Timezone fields in config are NOT used

## Code Quality

- **Formatting**: Black, 100 char line length
- **Linting**: Ruff (E, F, I, N, W, UP rules)
- **Type checking**: mypy (strict mode)
- **Tests**: pytest with pytest-asyncio
- **Unit Tests**: Whenever code changes are made, unit tests must be checked and updated if needed. Run `pytest` to verify all tests pass.
- Run `/quality-fix` before committing

## Backward Compatibility

**CRITICAL: Before making any change that affects APIs, function signatures, or configuration:**

1. **Ask**: Does this change need to be backward compatible?
2. **For this project**: This is a **new, never-released application** - **backward compatibility is NOT required**
3. **When making breaking changes**:
   - ✅ Remove old/deprecated parameters, functions, or code paths
   - ✅ Update all call sites and tests to use the new approach
   - ✅ Clean up any legacy compatibility code
   - ❌ Do NOT add backward compatibility code unless explicitly required
   - ❌ Do NOT keep deprecated parameters "for compatibility"

**If backward compatibility is needed** (e.g., for a released library):
- Add deprecation warnings with clear migration paths
- Document removal timeline
- Provide migration examples

## Error Handling Pattern

Use result dataclasses instead of exceptions for control flow:

```python
@dataclass
class Result:
    success: bool
    data: bytes | None = None
    error: str | None = None

def operation() -> Result:
    try:
        return Result(success=True, data=...)
    except Exception as e:
        return Result(success=False, error=str(e))
```

## Testing Pattern

Use dependency injection for external dependencies:

```python
_subprocess_run: Callable = subprocess.run

def set_subprocess_run(func: Callable) -> None:
    global _subprocess_run
    _subprocess_run = func
```

## Logging

- **Only lifecycle events**: start/stop, first connections, captures, uploads, schedule changes
- **Format**: `"Captured image at {time_str} ({mode_str} mode)"`
- **Timer format**: `"{hours}:{minutes:02d}:{seconds:02d}"`
- **Never log passwords** - redact with `***` if needed

## Module Structure

- Module-level docstring required
- Support both package and script execution:
```python
try:
    from .module import func
except ImportError:
    sys.path.insert(0, str(Path(__file__).parent.parent))
    from src.module import func
```

## File Organization

**Prefer separate files for distinct features:**

- ✅ Split large files into smaller, focused modules (one feature/concern per file)
- ✅ Extract complex logic into dedicated modules (e.g., `sftp_upload_meta_json.py` for JSON generation)
- ✅ Keep files focused and testable - easier to navigate and maintain
- ❌ Avoid monolithic files with many unrelated functions or classes
- ❌ Don't cram multiple features into a single file just to reduce file count

**Rationale**: Smaller, focused files are:
- Easier to test (can test features in isolation)
- Easier to navigate (clear file names indicate purpose)
- Easier to maintain (changes are localized)
- Better for code review (smaller diffs)

**Example**: Instead of putting JSON generation logic in `upload_sftp.py`, extract it to `sftp_upload_meta_json.py` with its own test file.

## Special Cases

### RTSP Authentication
- **Always sanitize inputs** - passwords may contain special characters
- Use separate `rtsp_user`/`rtsp_password` config fields (not URL-embedded)
- Pass passwords **unencoded** in RTSP URLs (some cameras reject URL-encoded passwords)
- Only URL-encode username if it contains special characters
- Handle any RTSP camera, not just specific brands

### Async Operations
- Use `async`/`await` for I/O (HTTP, file I/O)
- Prevent concurrent captures with `is_running` flag
- Use `APScheduler` for async job scheduling

## Dependencies

**CRITICAL: When adding new dependencies, update BOTH files:**

- ✅ `pyproject.toml` - **Primary source of truth** for package dependencies (PEP 621). Used by pip when installing from git repositories (`pip install git+...`) or as a package.
- ✅ `requirements.txt` - Used for development/local installation (`pip install -r requirements.txt`)

**Both files must have the same dependencies with the same version constraints.**

Example: If adding `piexif>=1.1.3`:
1. Add to `pyproject.toml` under `[project]` → `dependencies`: `"piexif>=1.1.3"`
2. Add to `requirements.txt`: `piexif>=1.1.3`

**Why both?** 
- `pyproject.toml` is the modern standard (PEP 621) and is used by pip for package installation
- `requirements.txt` is used for local development workflows
- Missing from either file will cause installation failures in different scenarios

**Note:** `setup.py` is minimal and only used for `data_files` (systemd service). Package metadata comes from `pyproject.toml`.

## Configuration

- Pydantic models for validation
- YAML format with comments
- Environment variable: `CONFIG_PATH` for config file location
- Never commit `config.yaml` (contains secrets)

## Quick Checklist

- [ ] All functions typed
- [ ] All times UTC
- [ ] Result objects for errors (not exceptions)
- [ ] Dependency injection for testability
- [ ] No passwords in logs
- [ ] Graceful degradation (optional features don't crash service)
- [ ] Docstrings for public functions
- [ ] Code formatted and linted
- [ ] Unit tests checked and updated if needed (run `pytest` to verify)
- [ ] **Dependencies added to BOTH `requirements.txt` AND `pyproject.toml`**
- [ ] **Backward compatibility considered** - removed legacy code if not needed
- [ ] **Features split into separate files** - avoid monolithic files with many concerns
